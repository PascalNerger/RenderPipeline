#pragma once

#include "PBR/Core/BaseTypes.h"
#include "PBR/Core/RefCounting.h"


namespace EngineCore
{

	////////////////////////////////////////////////////////////////////////////////////////////////////
	// TextureFormat ///////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////

	enum class TextureFormat : uint8
	{

		None			= 0,
		Rg				= 1,
		Rg16f			= 2,
		Rgb				= 3,
		Rgb16f			= 4,
		Rgb32f			= 5,
		Rgba			= 6,
		Rgba16f			= 7,
		Rgba32f			= 8,
		Srgb			= 9,
		Luminance		= 10,
		LuminanceAlpha	= 11,
		Depth			= 12,
		Depth16			= 13,
		Depth32			= 14,

	};

	////////////////////////////////////////////////////////////////////////////////////////////////////
	// TextureFilter ///////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////

	enum class TextureFilter : uint8
	{

		None		= 0,
		Nearest		= 1,
		Linear		= 2

	};

	////////////////////////////////////////////////////////////////////////////////////////////////////
	// TextureWrap /////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////

	enum class TextureWrap : uint8
	{

		None			= 0,
		Repeat			= 1,
		Clamp			= 2,
		ClampToEdge		= 3,
		ClampToBorder	= 4

	};

	////////////////////////////////////////////////////////////////////////////////////////////////////
	// TextureDataType /////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////

	enum class TextureDataType : uint8
	{

		None			= 0,
		UnsignedByte	= 1,
		UnsignedInt		= 2,
		Float			= 3,

	};

	////////////////////////////////////////////////////////////////////////////////////////////////////
	// TextureCreateInfo ///////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////

	struct TextureCreateInfo
	{

		TextureDataType DataType = TextureDataType::UnsignedByte;

		TextureFormat Format = TextureFormat::Rgba;
		TextureFormat InternalFormat = TextureFormat::Rgba;

		TextureFilter Filter = TextureFilter::Nearest;
		TextureWrap Wrap = TextureWrap::Clamp;

		bool UseMipMaps = false;
		float AnisotropyLevel = 0.0f;

		bool IsShadowTexture = false;

	};

	////////////////////////////////////////////////////////////////////////////////////////////////////
	// Texture /////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////

	struct Texture : public RefCountedObject
	{

		virtual ~Texture() { }

		virtual void Bind(uint32 slot = 0) const = 0;
		virtual void Unbind() const = 0;

		virtual uint64 GetShaderHandle() const = 0;

	};

	using TextureRef = Ref<Texture>;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	// Texture2d ///////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////

	struct Texture2D : public Texture
	{

		virtual ~Texture2D() { }

		virtual void SetData(const byte* data) = 0;

		virtual uint32 GetWidth() const = 0;
		virtual uint32 GetHeight() const = 0;


		static Ref<Texture2D> Create(const uint32 width, const uint32 height, const TextureCreateInfo& createInfo = TextureCreateInfo());
		static Ref<Texture2D> Create(const uint32 width, const uint32 height, const void* data, const TextureCreateInfo& createInfo = TextureCreateInfo());

	};

	using Texture2DRef = Ref<Texture2D>;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	// CubeMapOrientation //////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////

	enum class CubeMapOrientation
	{

		None = 0,
		PositiveX = 1,
		NegativeX = 2,
		PositiveY = 3,
		NegativeY = 4,
		PositiveZ = 5,
		NegativeZ = 6

	};

	////////////////////////////////////////////////////////////////////////////////////////////////////
	// CubeMapCreateData ///////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////

	struct CubeMapCreateData
	{

		const byte* Top = nullptr;
		const byte* Bottom = nullptr;
		const byte* Left = nullptr;
		const byte* Right = nullptr;
		const byte* Front = nullptr;
		const byte* Back = nullptr;

	};

	////////////////////////////////////////////////////////////////////////////////////////////////////
	// CubeMapTexture //////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////

	struct TextureCube : public Texture
	{

		virtual ~TextureCube() { }

		virtual void SetData(const byte* data, const CubeMapOrientation orientation) = 0;

		virtual uint32 GetWidth() const = 0;
		virtual uint32 GetHeight() const = 0;

		static Ref<TextureCube> Create(const uint32 width, const uint32 height, const TextureCreateInfo& createInfo = TextureCreateInfo());
		static Ref<TextureCube> Create(const uint32 width, const uint32 height, const CubeMapCreateData& data, const TextureCreateInfo& createInfo = TextureCreateInfo());

	};

	using TextureCubeRef = Ref<TextureCube>;

}